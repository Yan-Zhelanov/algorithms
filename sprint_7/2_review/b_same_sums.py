# 64235344

"""
    --- Принцип работы ---
Если сумма всех элементов чётная, то разделить множество на два равных по
суммам множества возможно, в противном случае нет, отсюда следует, что нам
нужно получить из какого-либо множества чисел сумму равную половине суммы всего
множества. Из пустого множества элементов можно получить только ноль. Далее
будем перебирать по очереди каждый элемент множества и отмечать все возможные
результаты, которые мы можем получить пользуясь данным элементом и предыдущими.
Если одна из комбинаций элементов даст нам половину от суммы всех элементов,
значит такие два множества существуют.

    --- Доказательство корректности ---
Из описания следует, что на каждом шаге мы будем отмечать те числа, которые мы
можем получить из множества уже рассмотренных элементов. В самом конце мы
рассмотрим все элементы множества, а значит и посчитаем все результаты, которые
мы можем получить из данного множества, отсюда следует, что мы сможем ответить
можно ли из данного множества получить такое множество элементов, которое в
сумме будет равняться половине от суммы всех элементов.

    --- Временная сложность ---
В лучшем случае: O(1), если первый элемент в массиве будет являться половиной
от суммы всего множества.
В худшем и среднем случаях: O(n * k/2), где n — количество элементов, а k
сумма всех элементов.

   --- Пространственная сложность ---
Для данной реализации нужно хранить половину от суммы всего множества и равное
этому же значению количество элементов в массиве: O(k/2 + 1)
Итого в худшем, среднем и лучшем случаях: O(k)
"""


def is_same_sums(array):
    need = sum(array)
    if need % 2 != 0:
        return False
    need //= 2
    dp = [False] * (need+1)
    dp[0] = True
    for i in range(1, len(array)+1):
        for j in range(need, 0, -1):
            remainder = j - array[i-1]
            if remainder < 0:
                continue
            if not dp[remainder] or dp[j]:
                continue
            if j == need:
                return True
            dp[j] = True
    return dp[-1]


def test_is_same_sums():
    result = is_same_sums([1, 7, 5, 1])
    assert result
    result = is_same_sums([1, 1, 1])
    assert not result
    result = is_same_sums([3, 5, 10])
    assert not result
    result = is_same_sums([7, 7, 1, 1, 2])
    assert result
    result = is_same_sums([1, 2, 3, 4, 5, 1])
    assert result
    result = is_same_sums([3, 1, 1, 2, 2, 1])
    assert result
    result = is_same_sums([])
    assert result
    print('All tests passed!')


if __name__ == '__main__':
    # test_is_same_sums()
    input()
    print(is_same_sums(list(map(int, input().split()))))
